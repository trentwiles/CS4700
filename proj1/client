#!/usr/bin/env python3

import socket
import ssl
import json
import sys
import argparse
import requests
import random

# constants (all caps in python!!!)
ENDLINE = "\n"
DEFAULT_HOST = "proj1.4700.network"
DEFAULT_PORT = 27993
DEFAULT_TLS_PORT = 27994
WORD_LIST_URL = "https://4700.network/projects/project1-words.txt"

# grab the word list from remote, per spec
def load_word_list():
    try:
        response = requests.get(WORD_LIST_URL, headers={"user-agent": "trent"})
        response.raise_for_status()  # kill if bad http status but unlikely

        # convert wordlist to a python list, filter junk
        return [
            word.strip().lower() for word in response.text.split("\n") if word.strip()
        ]
    except:
        raise ValueError("cuoldn't grab the wordlist")


# python string to UTF + newline at the end
def send_json(sock, msg):
    message = json.dumps(msg) + ENDLINE
    sock.sendall(message.encode("utf-8"))


# parse JSON response from socket, kill program if non-json response (there shouldn't be)
def recv_json(sock_file):
    line = sock_file.readline()
    if not line:
        raise ConnectionError("server closed connection")
    try:
        return json.loads(line.strip())
    except:
        raise ValueError("unable to parse JSON, try again later")

def is_valid_candidate(candidate, guessed_word, marks):
    # Count letters in the target word based on marks
    target_letter_counts = {}
    
    # if letter is preent in correct position, increase frequency count by 1
    for i, (letter, mark) in enumerate(zip(guessed_word, marks)):
        if mark == 2:
            target_letter_counts[letter] = target_letter_counts.get(letter, 0) + 1
    
    # if letter is present but in wrong position, still increase frequency count by 1
    for i, (letter, mark) in enumerate(zip(guessed_word, marks)):
        if mark == 1:
            target_letter_counts[letter] = target_letter_counts.get(letter, 0) + 1
    
    # add to forbidden letter "blocklist" if not letter isn't already in the target_letter dict
    forbidden_letters = set()
    for i, (letter, mark) in enumerate(zip(guessed_word, marks)):
        if mark == 0 and letter not in target_letter_counts:
            forbidden_letters.add(letter)
    
    # validate the candidate
    # forbidden letters
    for letter in forbidden_letters:
        if letter in candidate:
            return False
    
    # required letter counts
    candidate_counts = {}
    for letter in candidate:
        candidate_counts[letter] = candidate_counts.get(letter, 0) + 1
    
    # verify that the candidate word has at least the required number of each letter
    for letter, required_count in target_letter_counts.items():
        if candidate_counts.get(letter, 0) < required_count:
            return False
    
    # position constraints based on previous guess feedback from server
    # zip/iteration -> https://www.w3schools.com/python/ref_func_zip.asp
    for i, (letter, mark) in enumerate(zip(guessed_word, marks)):
        if mark == 2 and candidate[i] != letter:
            return False
        elif mark == 1 and candidate[i] == letter:
            return False
    
    return True


# clean out the word list after each guess
def filter_candidates(word_list, guesses):
    candidates = []
    guessed_words = set()

    for guess in guesses:
        guessed_words.add(guess["word"])

    for word in word_list:
        # bypass previously guessed words
        if word in guessed_words:
            continue

        # for each word in the word list, validate, then if validated, add to the list of candidates
        is_valid = True
        for guess_data in guesses:
            if not is_valid_candidate(word, guess_data["word"], guess_data["marks"]):
                is_valid = False
                break

        if is_valid:
            candidates.append(word)

    return candidates


def choose_next_guess(word_list, guesses):
    if not guesses:
        # no guesses? find a random word from the word list and don't fitler the list
        # some good "seed" words that have lots of vowels
        starters = ["adieu", "audio", "arose", "raise", "slate"]
        return starters[random.randint(0, len(starters) - 2)]

    candidates = filter_candidates(word_list, guesses)

    # use a random candidate
    if len(candidates) == 0:
        # no candidates? fall back to random word
        return word_list[random.randint(0, len(word_list) - 2)]
    
    return candidates[random.randint(0, len(candidates) - 1)]


def play_game(sock, sock_file, username, word_list):
    # send hello to grab ID
    hello_msg = {"type": "hello", "northeastern_username": username}
    send_json(sock, hello_msg)

    # get start message
    response = recv_json(sock_file)
    if response.get("type") == "error":
        raise ValueError(f"Websocket error: {response.get('message', 'Unknown error')}")

    if response.get("type") != "start":
        raise ValueError(f"Expected 'start' message, got: {response}")

    game_id = response["id"]

    # 500 guesses until we get kicked according to the docs
    guess_count = 0
    max_guesses = 500

    while guess_count < max_guesses:
        if guess_count == 0:
            next_guess = choose_next_guess(word_list, [])
        else:
            # server stores the previous guesses for us in the returned JSON, so we don't even need to store them in a variable
            next_guess = choose_next_guess(word_list, response.get("guesses", []))

        # print(f"Guess {guess_count + 1}: {next_guess}")
        # ^ uncomment above for debug

        # make the guess
        guess_msg = {"type": "guess", "id": game_id, "word": next_guess}
        send_json(sock, guess_msg)
        guess_count += 1

        # grab the response
        response = recv_json(sock_file)

        if response.get("type") == "error":
            error_msg = response.get("message", "Unknown error")
            raise ValueError(f"Server error: {error_msg}")
        elif response.get("type") == "bye":
            # bingo, we found the correct one
            return response["flag"]
        elif response.get("type") == "retry":
            # if response.get("guesses"):
            #     remaining = filter_candidates(word_list, response["guesses"])
            # print(f"Candidates remaining: {len(remaining)}")
            # ^ uncomment above for debug

            continue
        else:
            raise ValueError(f"Unexpected response type: {response.get('type')}")

    raise ValueError("maximum number of guesses (500) exceeded")
    # future ^^^ add logic to reconnect once 500+ limit has been passed
    # however I have never used more than 20 guesses


def main():
    # https://realpython.com/command-line-interfaces-python-argparse/
    parser = argparse.ArgumentParser(
        description="Project #1, CS 4700 (Trent Wiles)"
    )
    parser.add_argument("-p", "--port", type=int, help="Server port")
    parser.add_argument("-s", "--tls", action="store_true", help="Use TLS?")
    parser.add_argument("hostname", help="Server hostname")
    parser.add_argument("username", help="NEU username")

    args = parser.parse_args()

    # fallback to predefined default ports as specified in docs if user doesn't override
    # defined in constants at top of file
    if args.port:
        port = args.port
    elif args.tls:
        port = DEFAULT_TLS_PORT
    else:
        port = DEFAULT_PORT

    word_list = load_word_list()

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        if args.tls:
            context = ssl.create_default_context()
            sock = context.wrap_socket(sock, server_hostname=args.hostname)

        sock.connect((args.hostname, port))
        # sock_file allows us to treat the socket like the file I/O, just like prof noted in class
        sock_file = sock.makefile("r")

        flag = play_game(sock, sock_file, args.username, word_list)

        # only required output is printing the flag
        print(flag)

    except Exception as e:
        print(f"error: {e}", file=sys.stderr)
    finally:
        try:
            sock.close()
        except:
            pass



if __name__ == "__main__":
    main()
